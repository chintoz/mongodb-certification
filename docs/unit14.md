# MongoDB Atlas Search

## Lesson 1: Using Relevance-Based Search and Search Indexes

Atlas search is a powerful tool created into MongoDB Atlas that allows you to create search experiences for users of your app without creating search algorithm.

### Relevance-Based Search

It's a kind of Atlas search within an application users seeks for surface records based on a search term. It's not a database search for a particular record. It's similar to a search bar on a website.

Search on different data types it's hard and sometimes external tools are used for that purpose. MnoDB Atlas Search is a tool that allows you to create search experiences for users of your app without creating search algorithm.

It's integrated Apache Lucene search engine that allows you to create search indexes and search queries.

Atlas search starts with search indexes which are no the same as database indexes. Database indexes are used by developers and database administrators to make their frequent database queries easier and more efficient. Search indexes specify how records are referenced for relevance-based search.


## Lesson 2: Creating a Search Index with Dynamic Mapping

Search index defines how a search should be performed. It's a set of rules that define how the search engine should interpret the data in the collection.

A search index with dynamic mapping means all fields indexed (except booleans, objectIds and timestamps) are indexed by default (even nested fields). This is useful when you have a large number of fields, and you don't want to create a mapping for each one.

By default index analyzer and search analyzer are going to be created using lucene standard analyzer. You can also specify a custom analyzer depends on your language or use case. 

If we specify dynamic mapping we don't need to specify any field mapping for this kind of indexes.

Once the index is created, we can do queries and it'll return the results a the score assigned to this search value. This search score is going to be generated by the search engine based on the relevance of the search term to the document.

In the following example we are going to create a search index with dynamic mapping on `birds` collection:

```mongodb-json
{
  "name": "sample_analytics-birds-dynamic",
  "searchAnalyzer": "lucene.standard",
  "analyzer": "lucene.standard",
  "collectionName": "birds",
  "database": "sample_analytics",
  "mappings": {
    "dynamic": true
  }
}
```

During the lab a search index was created using this command:

```bash
atlas clusters search indexes create --clusterName myAtlasClusterEDU -f /app/search_index.json
```

And it was queries using this one:

```bash
atlas clusters search indexes list --clusterName myAtlasClusterEDU --db sample_supplies --collection sales
```

Furthermore in the lab it was created a search on seach index using this sample:

```javascript
db = db.getSiblingDB("sample_supplies")

var pipeline = [
{
  "$search": {
    index: "sample_supplies-sales-dynamic",
    text: {
      query: "notepad", 
      path: { "wildcard": "*" }
    } } },
{
  "$set": {
    score: { 
      "$meta": "searchScore" }
    }
}
]

var result = db.sales.aggregate(pipeline)

print(result)
```
## Lesson 3: Creating a Search Index with Static Field Mapping

If we have huge amount of fields, and we know some of them are not relevant for the search index, we can use static mapping to specify which fields are going to be indexed. It's called static indexing, it means the fields being queried are always the same.

It's going to minimize the query workload because the number of fields indexed and the amount of data to scan is minimal.

During the video a static field index created on some of the field from birds colletion.

```mongodb-json
{
  "name": "sample_analytics-birds-static",
  "searchAnalyzer": "lucene.standard",
  "analyzer": "lucene.standard",
  "collectionName": "birds",
  "database": "sample_analytics",
  "mappings": {
    "dynamic": false,
    "fields": {
      "common_name": {
        "type": "string"
      },
      "diet": {
        "type": "string"
      },
      "habitat": {
        "type": "string"
      },
      "scientific_name": {
        "type": "string"
      }
    }
  }
}
```

During the lab this index was created using this command:

```mongodb-json
{
    "name": "sample_supplies-sales-static",
    "searchAnalyzer": "lucene.standard",
    "analyzer": "lucene.standard",
    "collectionName": "sales",
    "database": "sample_supplies",
    "mappings": {
        "dynamic": false,
        "fields": {
            "storeLocation": {
                "type": "string"
            }
        }
    }
}
```

And it was launched with the commands to create index and query via search index similar to the previous lesson.

A second part of the lab encourage to create a search pipeline using the search index:

```mongodb-json
db.sales.aggregate([
{
  "$search": {
    index: "sample_supplies-sales-static",
    text: {
      query: "London", 
      path: { "wildcard": "*" }
    } } },
{
  "$set": {
    score: { 
      "$meta": "searchScore" }
    }
}
])
```

## Lesson 4: Using $search and Compound Operators

Atlas includes a built in tool to test basic operations on search indexes. To add customizations we need to create a `$search` stage in the aggregation pipeline. We can use our Java language to create our pipeline using this search stage.

In the search stage there are several options to customize the search. This is the structure of the search stage:

```mongodb-json
{
  "$search": {
    "index": "indexName",
    "operatorName" | "collectorName" : {
      operatorSpecification | collectorSpecification
    },
    highlight: {
        highlightOptions
    },
    count: {
        countOptions
    },
    returnStoredSources:  true | false,
  }
}
```

We can configure the index to use, options about how much text to return with the search terms (highlight section), number of total documents (count section), if we want to return the stored sources and `$compound` operators described in operatorName or collectorName.

The `$compound` operator is nested in search stage. Their clauses are:

* must: all clauses must match
* must not: all clauses must not match
* should: which will assign weights to records that match the clause
* filter: which will filter the results based on the clause. It will eliminate documents which don't match the clause, but it won't affect the score.

We are going to do an example based on the birds collection, with those conditions: live in grasslands, and should have large wingspan.

```mongodb-json
[
  {
    $search: {
      compound: {
        must: [
          {
            text: {
              query: "grassland",
              path: "habitat",
            },
          },
        ],
        should: [
          {
            range: {
              gte: 75,
              path: "wingspam:_cm",
              score: {
                constant: {
                  value: 5,
                },
              },
            },
          },
        ],
      },
    },
  },
]
```

In this case it's filtering those birds that live in grasslands, and it prioritizes those with large wingspan adding 5 points to the score of the document.

Based on the lab this is a concrete example using filter and should:
    
```mongodb-json
db.sales.aggregate([
  {
    $search: {
      index: 'sample_supplies-sales-dynamic',
      "compound": {
        "filter": [
          {
            "text": {
              "query": "Online",
              "path": "purchaseMethod"
            }
          }
        ],
        "should": [
          {
            "text": {
              "query": "notepad",
              "path": "items.name",
              "score": { "constant": { "value": 5 } }
            }
          }
      ]
      }
    }
  },
  {
    $project: {
    "items.name": 1,
    "purchaseMethod": 1,
    "score": { $meta: "searchScore" }
    }
  }
])
```


## Lesson 5: Group Search Results by Using Facets

Facets are buckets that we group our search results into. At the end we are creating categories for our search results. We can use facets to group our search results by a field or by a range of values.

The data types to be consider for facets are: numbers, dates and strings. When we create the index with dynamic mapping, we could select data type like DateFacet, RangeFacet or StringFacet.

To query by those fields, we will use $searchMeta operator. This operator will return the facets and the count of the documents that match the search query. It allows us to see the facets and how many results are in each bucket.

The buckets that the search will be filtered into are not part of the search results themselves, they are part of the search metadata. The search metadata is returned in the search results. This is information about how the search was carried out.

There are two pieces of metadata returned by atlas search: the facets, and the count which is the number of results in each of the facets.

Here an example
    
```mongodb-json
db.sightings.aggregate([
  {
    $searchMeta: {
      facet: {
        operator: {
          text: {
            query: ["Northern Cardinal"],
            path: "common_name"
          }
        },
        facets: {
          sightingWeekFacet: {
            type: "date",
            path: "sighting",
            boundaries: [
              ISODate("2022-01-01"), 
              ISODate("2022-01-08"),
              ISODate("2022-01-15"),
              ISODate("2022-01-22")
            ],
            default: "other"
          }
        }
      }
    }
  }
])
```

In this lab is going to be shown how to create a search index with static mapping (search_index.json).

```mongodb-json
{
    "name": "sample_supplies-sales-facets",
    "searchAnalyzer": "lucene.standard",
    "analyzer": "lucene.standard",
    "collectionName": "sales",
    "database": "sample_supplies",
    "mappings": {
        "dynamic": true,
        "fields": {
        "purchaseMethod": [
            {
            "dynamic": true,
            "type": "document"
            },
            {
            "type": "string"
            }
        ],
        "storeLocation": [
            {
            "dynamic": true,
            "type": "document"
            },
            {
            "type": "stringFacet"
            }
        ]
        }
    }
}
```
Command to create a search index via CLI:

```bash
atlas clusters search indexes create --clusterName myAtlasClusterEDU -f /app/search_index.json
```

Listing existing indexes

```bash
atlas clusters search indexes list --clusterName myAtlasClusterEDU --db sample_supplies --collection sales
```

Last lab exercise about a query using facets:

```mongodb-json
db.sales.aggregate([
  {
    $searchMeta: {
      index: 'sample_supplies-sales-facets',
        "facet": {
            "operator": {
                "text": {
                    "query": "In store",
                    "path": "purchaseMethod"
                }
            },
            "facets": {
                "locationFacet": {
                    "type": "string",
                    "path": "storeLocation",
                }
            }
        }
    }
  }
])
```

In summary facet is the similar operator in queries for grouping, however in Atlas search engine we cannot use it, and we need to use $searchMeta operator to get the facets and the count of the documents that match the search query.

